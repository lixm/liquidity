
Require Import escrow.
Require Import LibTactics. 


Section Liquidity. 

  Require Coq.NArith.NArith. 
  Require stdpp.countable.
  Local Open Scope Z_scope.

  Set Primitive Projections.
  Set Nonrecursive Elimination Schemes.
  Context {AddrSize : N}.

  Ltac reduce_init_escrow :=
    match goal with
    | H : init ?chain ?ctx ?setup = Ok ?state |- _ =>
        unfold init in H;
        match type of H with
          context [?t1 && ?t2 && ?t3 && ?t4 && ?t5 && ?t6 && ?t7 && ?t8] => 
            destruct (t1 && t2 && t3 && t4 && t5 && t6 && t7 && t8) eqn: Einit in H;  
            try discriminate; 
            simpl in H
        end
    end.

  Ltac reduce_receive_escrow :=
    match goal with
    | H : receive ?chain ?ctx ?st ?msg = Ok (?new_st, ?acts) |- _ =>
        unfold receive in H;
        destruct (require_zero ctx && require_not_self_call ctx) eqn:Ezero in H; try discriminate;
        destruct msg eqn:Emsg in H; try discriminate;
        simpl in H
    end.

  Ltac reduce_markAsShipped :=
    match goal with
    | H : markAsShipped ?chain ?ctx ?st = Ok (?new_st, ?acts) |- _ =>
        unfold markAsShipped in H;
        destruct ((require_phase st AWAITING_SHIPMENT) &&
                    (require_sender ctx st.(seller))) eqn:Emark in H;
        try discriminate;
        simpl in H
    end.

  Ltac reduce_acceptItem :=
    match goal with
    | H : acceptItem ?chain ?ctx ?st = Ok (?new_st, ?acts) |- _ =>
        unfold acceptItem in H;
        destruct ((require_phase st AWAITING_ACCEPTANCE) &&
                    (require_sender ctx st.(buyer))) eqn:Eaccept in H;
        try discriminate;
        simpl in H
    end.

  Ltac reduce_rejectItem :=
    match goal with
    | H : rejectItem ?chain ?ctx ?st = Ok (?new_st, ?acts) |- _ =>
        unfold rejectItem in H;
        destruct ((
              require_phase st AWAITING_ACCEPTANCE ||
                require_phase st AWAITING_SHIPMENT
          )) eqn:Ereject in H;
        try discriminate;
        simpl in H
    end.

  Ltac reduce_arbitrate :=
    match goal with
    | H : arbitrate ?chain ?ctx ?st ?buyerWins = Ok (?new_st, ?acts) |- _ =>
        unfold arbitrate in H;
        destruct ((require_phase st DISPUTED) &&
                    (require_sender ctx st.(arbitrator))) eqn:Earb in H;
        try discriminate;
        simpl in H
    end.

  Tactic Notation "contract_simpl" := contract_simpl @receive @init.

  Ltac destruct_message :=
    repeat match goal with
      | H : Blockchain.receive _ _ _ _ _ = Ok _ |- _ => unfold Blockchain.receive in H; cbn in H
      | msg : option Msg |- _ => destruct msg
      | msg : Msg |- _ => destruct msg
      | H : Blockchain.receive _ _ _ _ None = Ok _ |- _ => now contract_simpl
      | H : receive _ _ _ None = Ok _ |- _ => now contract_simpl
      end.

  Let caddr := escrow.caddr.
  Let miner := escrow.miner.

  Variable s0 : ChainState.

  Hypothesis H_init: is_init_state contract caddr s0.
  Hypothesis H_miner : address_not_contract miner = true.

  Let seller_adr := escrow.seller_adr. 
  Let buyer_adr := escrow.buyer_adr.
  Let arbitrator_adr := escrow.arbitrator_adr. 

  Definition seller_call_MarkAsShipped (state : State) : Action :=
    build_call seller_adr caddr 0 MarkAsShipped.

  Definition seller_call_RejectItem (state : State) : Action :=
    build_call seller_adr caddr 0 RejectItem.

  Definition buyer_call_AcceptItem (state : State) : Action :=
    build_call buyer_adr caddr 0 AcceptItem.

  Definition buyer_call_RejectItem (state : State) : Action :=
    build_call buyer_adr caddr 0 RejectItem.

  Definition arbitrator_call_Arbitrate (state : State) (bWins: bool) : Action :=
    build_call arbitrator_adr caddr 0 (Arbitrate bWins).

  Inductive phase_ord: EscrowPhase -> EscrowPhase -> Prop :=
    AS_AA: phase_ord AWAITING_ACCEPTANCE AWAITING_SHIPMENT 
  | AA_CP: phase_ord COMPLETED AWAITING_ACCEPTANCE 
  | AA_DP: phase_ord DISPUTED AWAITING_ACCEPTANCE 
  | AS_DP: phase_ord DISPUTED AWAITING_SHIPMENT 
  | DP_CP: phase_ord COMPLETED DISPUTED 
  | Trans ep1 ep2 ep3:
    phase_ord ep1 ep2 -> phase_ord ep2 ep3 -> phase_ord ep1 ep3.

  Definition var_func (csref cs: ChainState) : option EscrowPhase :=
    match contract_state cs caddr with
      Some st => Some st.(currentPhase)
    | None => None        
    end.

  Definition inv_func (csref cs: ChainState) : Prop :=
    transition_reachable miner contract caddr s0 cs /\
      exists cst,
        contract_state cs caddr = Some cst /\
          (cst.(currentPhase) = COMPLETED -> env_account_balances cs caddr = 0). 

  Lemma none_lt_completed:
    forall y z,  
      phase_ord y z ->
      z = COMPLETED ->
      False.
  Proof.
    introv Hf.
    induction Hf; 
      try (intro Hf; inverts Hf).
    tryfalse. 
  Qed.

  Lemma elems_lt_disputed:
    forall y z,
      phase_ord y z ->
      z = DISPUTED ->
      y = COMPLETED. 
  Proof.
    introv Hpo.
    induction Hpo; try (introv Hf; inverts Hf); auto.
    specializes IHHpo2; eauto.
    rewrite IHHpo2 in Hpo1.
    apply none_lt_completed in Hpo1; tryfalse.
    auto.
  Qed. 
    
  Lemma elems_lt_awaiting_acceptance:
    forall y z,
      phase_ord y z ->
      z = AWAITING_ACCEPTANCE ->
      (y = DISPUTED \/ y = COMPLETED). 
  Proof.
    introv Hpo.
    induction Hpo; introv H_; tryfalse; eauto.
    specializes IHHpo2; eauto.
    destruct IHHpo2 as [Heq | Heq].
    - rewrite Heq in Hpo1. apply elems_lt_disputed in Hpo1; auto.
    - rewrite Heq in Hpo1. apply none_lt_completed in Hpo1; auto. false. 
  Qed. 
    
  Lemma elems_lt_awaiting_shipment: 
    forall y z,
      phase_ord y z ->
      z = AWAITING_SHIPMENT ->
      y = AWAITING_ACCEPTANCE \/ y = DISPUTED \/ y = COMPLETED. 
  Proof.
    introv Hpo.
    induction Hpo; introv H_; tryfalse; eauto.
    destruct (IHHpo2 H_) as [H | [H | H]]. 
    - rewrite H in Hpo1. apply elems_lt_awaiting_acceptance in Hpo1; auto.
    - rewrite H in Hpo1. apply elems_lt_disputed in Hpo1; auto.
    - rewrite H in Hpo1. apply none_lt_completed in Hpo1; auto. false. 
  Qed.
  
  Lemma acc_completed:
    Acc phase_ord COMPLETED.
  Proof.
    constructors. introv Hpo. apply none_lt_completed in Hpo; auto. false.
  Qed.

  Program Instance liqVerif : LiqVerif := {
      A := EscrowPhase;
      Ord := phase_ord;
      Inv := inv_func;
      Var := var_func;

      setup := Setup;
      msg := Msg; 
      state := State;
      error := Error;

      cur_adr := caddr;
      inist := s0;
      theCtr := contract; 

      miner_adr := miner;
      H_mnctr := H_miner; 
    }. 
  Next Obligation.
    unfold well_founded.
    intros. constructors.
    introv Hpo.
    induction Hpo.  
    - constructors.
      introv Hpo. apply elems_lt_awaiting_acceptance in Hpo; auto.
      destruct Hpo as [Hy | Hy].
      + subst y. constructors. introv Hpo.
        apply elems_lt_disputed in Hpo. subst y.
        apply acc_completed. auto.
      + subst y. apply acc_completed.
    - apply acc_completed.
    - constructors. introv Hpo. apply elems_lt_disputed in Hpo; auto.
      subst. apply acc_completed.
    - constructors. introv Hpo. apply elems_lt_disputed in Hpo; auto.
      subst. apply acc_completed.
    - apply acc_completed.
    - auto.
  Qed. 
  Next Obligation.
    introv Hpo12 Hpo23.
    eapply Trans; eauto.
  Qed.

  Lemma minimal_completed: 
    minimal COMPLETED.
  Proof.
    unfolds.
    introv Hord.
    unfold Ord in Hord. 
    eapply none_lt_completed; eauto.
  Qed. 

  Lemma balance_on_chain :
    forall bstate caddr,
      reachable bstate ->
      let effective_balance :=
        (env_account_balances bstate caddr - (sumZ (fun act => act_body_amount act) (outgoing_acts bstate caddr)))%Z in
      env_contracts bstate caddr = Some (contract : WeakContract) ->
      exists cstate,
        contract_state bstate caddr = Some cstate /\
          effective_balance = cstate.(depositAmount).
  Proof.
    intros.
    unfold effective_balance.
    contract_induction; intros; auto; cbn in *;try congruence;try lia;eauto.
    - reduce_init_escrow.
      inversion init_some.
      simpl.
      lia.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped. cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        lia.
      + reduce_acceptItem . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        lia.
      + reduce_rejectItem  . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        lia.
      + reduce_arbitrate  . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        lia.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped. cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        inversion receive_some; destruct head; cbn in *; lia.
      + reduce_acceptItem . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        inversion receive_some; destruct head; cbn in *; lia.
      + reduce_rejectItem  . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        inversion receive_some; destruct head; cbn in *; lia.
      + reduce_arbitrate  . cbn in *.
        inversion receive_some. simpl.
        unfold require_zero in Ezero.
        propify.
        inversion receive_some; destruct head; cbn in *; lia.
    - now erewrite sumZ_permutation in IH by eauto.
    - solve_facts.
  Qed.

  Lemma COMPLETED_impl_bal:
    forall bstate, 
      reachable bstate ->
      env_contracts bstate caddr = Some (contract : WeakContract) ->
      exists cstate, 
        contract_state bstate caddr = Some cstate /\
          (cstate.(currentPhase) = COMPLETED -> (cstate.(depositAmount) = 0)%Z).
  Proof.
    contract_induction;intros;cbn in *;eauto;try congruence;try lia.
    - reduce_init_escrow.
      inversion init_some.
      subst.
      cbn in *.
      congruence.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped. cbn in *.
        inversion receive_some;subst;cbn in *.
        congruence.
      + reduce_acceptItem . cbn in *.
        inversion receive_some;subst;cbn in *.
        congruence.
      + reduce_rejectItem  . cbn in *.
        inversion receive_some;subst;cbn in *.
        congruence.
      + reduce_arbitrate  . cbn in *.
        inversion receive_some;subst;cbn in *.
        congruence.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped. cbn in *.
        inversion receive_some;subst;cbn in *;destruct head; cbn in *;try congruence.
      + reduce_acceptItem . cbn in *.
        inversion receive_some;subst;cbn in *;destruct head; cbn in *;try congruence.
      + reduce_rejectItem  . cbn in *.
        inversion receive_some;subst;cbn in *;destruct head; cbn in *;try congruence.
      + reduce_arbitrate  . cbn in *.
        inversion receive_some;subst;cbn in *;destruct head; cbn in *;try congruence.
    - solve_facts.
  Qed.

  Lemma seller_buyer_arbitrator_addr:
    forall bstate, 
      reachable bstate ->
      env_contracts bstate caddr = Some (contract : WeakContract) ->
      exists cstate,
        contract_state bstate caddr = Some cstate
        /\ cstate.(buyer) = buyer_adr 
        /\ cstate.(seller) = seller_adr
        /\ cstate.(arbitrator) = arbitrator_adr. 
  Proof.
    contract_induction;intros;cbn in *;eauto;try congruence;try lia.
    - reduce_init_escrow.
      inversion init_some.
      cbn in *.
      unfold buyer_adr, seller_adr, arbitrator_adr. 
      splits; eauto.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped. 
        inversion receive_some;subst;cbn in *.
        congruence. 
      + reduce_acceptItem. 
        inversion receive_some;subst;cbn in *.
        congruence.
      + reduce_rejectItem. 
        inversion receive_some;subst;cbn in *.
        congruence. 
      + reduce_arbitrate. 
        inversion receive_some;subst;cbn in *.
        congruence.
    - reduce_receive_escrow.
      destruct_message;try congruence.
      + reduce_markAsShipped.
        inversion receive_some; subst; cbn in *; destruct head; cbn in *; try congruence.
      + reduce_acceptItem.
        inversion receive_some; subst; cbn in *; destruct head; cbn in *; try congruence.
      + reduce_rejectItem.
        inversion receive_some; subst; cbn in *; destruct head; cbn in *; try congruence.
      + reduce_arbitrate.
        inversion receive_some; subst; cbn in *; destruct head; cbn in *; try congruence.
    - solve_facts.     
  Qed. 

  Program Instance contractCls : ContractCls := {
      ctr_setup := Setup;  
      ctr_msg := Msg; 
      ctr_state := State; 
      ctr_error := Error; 
      ctrCtr := contract; 
  }. 

  Lemma transition_reachable_inv:
    forall csref s',  
      transition_reachable miner contract caddr s0 s' -> 
      inv_func csref s'. 
  Proof.
    introv Htrc'.
    assert (Hrc': reachable s').
    {
      eapply transition_reachable_impl_reachable in Htrc'; eauto.
    }
    unfolds.
    split; auto.
    pose proof trans_rc_env_contracts as Htrec.
    unfold liqVerif in Htrec; simpl in Htrec.
    specializes Htrec; eauto.
    lets H__: COMPLETED_impl_bal Htrec; eauto.
    destruct H__ as (cs' & Hcst' & Himpl').
    lets H__: balance_on_chain Htrec; eauto.
    destruct H__ as (cs'_ & Hcs'_ & Heq).
    rewrite Hcs'_ in Hcst'. inverts Hcst'.
    assert (Hcsq': s'.(chain_state_queue) = []).
    { eapply transition_reachable_queue_is_empty in Htrc'; eauto. } 
    unfold outgoing_acts in Heq.
    rewrite Hcsq' in Heq.
    simpl in Heq.
    eexists; splits; eauto.
    introv Hcp. apply Himpl' in Hcp.
    lia.
  Qed. 

  Lemma recv_phase_ord: 
    forall (cs1 cs2: State) chain ctx msg acts, 
      Blockchain.receive ctrCtr chain ctx cs1 msg = Ok (cs2, acts) ->
      phase_ord cs2.(currentPhase) cs1.(currentPhase).
  Proof.
    introv Hrcv.
    unfold contractCls in Hrcv; simpl in Hrcv.
    unfolds in Hrcv.
    destruct_head Hrcv Ec tryfalse.
    destruct msg eqn: Em; tryfalse.
    destruct c; tryfalse.
    - unfolds in Hrcv.
      destruct_cond Hrcv Ecc tryfalse.
      inverts Hrcv.
      destruct (require_phase cs1 AWAITING_SHIPMENT) eqn: Er; simpl in Ecc; tryfalse.
      unfolds in Er.
      destruct_head Er Ecp tryfalse.
      simpl.
      constructors.
    - unfolds in Hrcv.
      destruct_cond Hrcv Ecc tryfalse.
      inverts Hrcv.
      simpl.
      destruct (require_phase cs1 AWAITING_ACCEPTANCE) eqn: Erp; simpl in Ecc; tryfalse.
      unfolds in Erp. destruct_head Erp Ecp tryfalse. 
      constructors.
    - unfolds in Hrcv.
      destruct_cond Hrcv Ecc tryfalse.
      inverts Hrcv.
      simpl.
      unfold require_phase in Ecc.
      destruct (currentPhase cs1); simpl in Ecc; tryfalse.
      constructors. constructors.
    - unfolds in Hrcv.
      destruct_cond Hrcv Ecc tryfalse.
      inverts Hrcv.
      simpl.
      destruct (require_phase cs1 DISPUTED) eqn: Edp; simpl in Ecc; tryfalse.
      unfolds in Edp.
      destruct_head Edp Ecp tryfalse.
      constructors. 
  Qed. 

  Lemma ctr_recv_st_upd_phase_ord: 
    forall (cst cst': State), 
      ctr_recv_st_upd cst cst' -> 
      phase_ord (currentPhase cst') (currentPhase cst) \/ currentPhase cst' = currentPhase cst.
  Proof.
    introv Hcrsu.
    induction Hcrsu.
    - auto.
    - apply recv_phase_ord in H.
      destruct IHHcrsu as [Hod | Heq].
      + left. constructors; eauto.
      + left. congruence.
  Qed. 
    
  Lemma transition_var_rel:
    forall sref s s' a n act,  
      inv_func sref s ->
      var_func sref s = Some a -> 
      transition miner n s act = Ok s' -> 
      exists a',
        var_func sref s' = Some a' /\ (Ord a' a \/ a' = a).
  Proof.
    introv Hif Hvf Htrans.
    assert (Htrans_ := Htrans).
    unfolds in Htrans.
    destruct_head Htrans Eqie tryfalse.
    destruct_head Htrans Eee tryfalse.
    inverts Htrans.
    unfolds in Eee.
    destruct_head Eee Evh tryfalse.
    destruct_head Eee Efonf tryfalse.
    destruct_head Eee Efira tryfalse.
    match type of Eee with
      context[execute_actions _ ?t _] => remember t as ss
    end.
    unfold inv_func in Hif.
    destruct Hif as (Htrc & (cst & Hcst & Himpl)).
    
    assert (Htrc': transition_reachable miner contract caddr s0 s').
    {
      eapply transition_reachable_transition_transition_reachable; eauto.
    }
    assert (Hrc': reachable s').
    {
      eapply transition_reachable_impl_reachable in Htrc'; eauto.
    }
    lets Hinv': transition_reachable_inv sref Htrc'; eauto.
    unfolds in Hinv'.
    destruct Hinv' as (_ & (cst' & Hcst' & Himpl')).
    unfold Ord. unfold liqVerif; simpl.
    assert (Hec: env_contracts s caddr = Some (contract: WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htrec.
      unfold liqVerif in Htrec; simpl in Htrec.
      eapply Htrec; eauto.
    }
    pose proof contract_recv_upd_states as Hrus.
    specialize (Hrus n contractCls ss s' cst cst' caddr Eee).
    specializes Hrus; eauto.
    { subst ss. simpl. auto. }
    { subst ss. simpl. unfold add_new_block_to_env, contract_state; simpl.
      unfolds in Hcst. dh Eecs tryfalse.  auto. }
    unfold var_func.
    rewrite Hcst'.
    eexists; splits; eauto.
    unfolds in Hvf.
    rewrite Hcst in Hvf. inverts Hvf.
    eapply ctr_recv_st_upd_phase_ord; eauto.
  Qed. 

  Lemma multiStratDrive_var_rel: 
    forall n sref s s' tr tr' a d_addrs d_strat,   
      inv_func sref s ->
      var_func sref s = Some a ->
      multiStratDrive miner d_addrs d_strat s0 s tr s' tr' n -> 
      exists a',
        var_func sref s' = Some a' /\ (Ord a' a \/ a' = a).
  Proof.
    induction n.
    - introv Hif Hvf Hmsd.
      inverts Hmsd.
      eexists; splits; eauto.      
      lia.
    - introv Hif Hvf Hmsd.
      inverts Hmsd.
      assert (count = n) by lia.
      subst count.
      lets H__: IHn Hif Hvf H2.
      destruct H__ as (a'' & Hvf'' & Hord'').
      inverts H3.
      destruct H as (n_ & Htrans & Hin & Htr').
      assert (transition_reachable miner contract caddr s0 s).
      {
        unfolds in Hif. destructs Hif; auto.
      }
      assert (Htrc'': transition_reachable miner contract caddr s0 s'0).
      {
        eapply transition_reachable_multiStratDrive_transition_reachable; eauto.
      }
      eapply transition_reachable_inv with (csref:=sref) in Htrc'' as Hif''; eauto.
      lets H_: transition_var_rel Hif'' Hvf'' Htrans.
      destruct H_ as (a' & Hvf' & Hord').
      eexists; splits; eauto.
      clear -Hord'' Hord'.
      unfold Ord in *. unfold liqVerif in *; simpl in *.
      destruct Hord'; destruct Hord''.
      left; constructors; eauto.
      subst. left; auto.
      subst. left; auto.
      right; congruence.
  Qed. 

  Lemma inv_var:
    forall csref cs, 
      inv_func csref cs ->
      var_func csref cs <> None.
  Proof.
    introv Hif Hn.
    unfolds in Hif.
    destruct Hif as (Htrc & (cst & Hcst & Himpl)).
    unfolds in Hn.
    rewrite Hcst in Hn.
    false. 
  Qed.

  Lemma VC_R_holds : VC_R.
  Proof.
    unfolds.
    introv Htrc. unfold Inv, Var.
    unfold liqVerif; simpl.
    unfold liqVerif in Htrc; simpl in Htrc.
    assert (Hif: inv_func cs cs).
    { eapply transition_reachable_inv; eauto. }
    split; auto.
    eapply inv_var; eauto.
  Qed.

  Lemma min_completed:
    forall a, minimal a -> a = COMPLETED.
  Proof.
    introv Hmin.
    unfolds in Hmin.
    unfold liqVerif in Hmin; simpl in Hmin.
    destruct a.
    - false. specialize (Hmin AWAITING_ACCEPTANCE).
      apply Hmin.
      constructors.
    - false. specialize (Hmin COMPLETED).
      apply Hmin.
      constructors.
    - auto.
    - specialize (Hmin COMPLETED).
      false. apply Hmin. constructors. 
  Qed. 

  Lemma VC_B_holds : VC_B (fun _ s' : ChainState => funds s' caddr = 0).
  Proof.
    unfolds.
    introv Hinv Hvar Hmin.
    unfolds.
    unfolds in Hinv. unfold liqVerif in Hinv; simpl in Hinv.
    unfold inv_func in Hinv.
    destruct Hinv as (Htrc & (cst & Hcst & Himpl)).
    eapply Himpl. 
    apply min_completed in Hmin.
    subst a.
    unfold Var in Hvar. unfold liqVerif in Hvar; simpl in Hvar.
    unfolds in Hvar. rewrite Hcst in Hvar.
    inverts Hvar. auto.
  Qed.     

  Lemma VC_A_holds:
    forall addrs strat, VC_A addrs strat.
  Proof.
    intros.
    unfolds.
    unfold Var, Inv.
    unfold liqVerif; simpl.
    introv Hvf Hif Hmsd.
    split.
    - assert (Htrc': transition_reachable miner contract caddr s0 cs').
      {
        unfolds in Hif. destructs Hif. 
        eapply transition_reachable_multiStratDrive_transition_reachable in H; eauto.
      }
      eapply transition_reachable_inv; eauto.
    - lets H__: multiStratDrive_var_rel Hif Hvf Hmsd.
      destruct H__ as (a' & Hvf' & Hord').
      unfold Ord in Hord'. unfold liqVerif in Hord'; simpl in Hord'.
      eexists; splits; eauto.
  Qed.     

  Lemma adr_is_ctr_false_buyer: 
    address_is_contract buyer_adr = false. 
  Proof.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    destruct Hex as (ctx & stp & st & Hst & Hini).
    simpl in Hini. 
    reduce_init_escrow.
    do 5 match goal with
        H: _ && _ = true |- _ => apply andb_prop in H; destruct H
      end.
    eapply address_not_contract_negb; eauto.
  Qed. 

  Lemma adr_is_ctr_false_seller: 
    address_is_contract seller_adr = false. 
  Proof.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    destruct Hex as (ctx & stp & st & Hst & Hini).
    simpl in Hini. 
    reduce_init_escrow.
    do 6 match goal with
        H: _ && _ = true |- _ => apply andb_prop in H; destruct H
      end.
    eapply address_not_contract_negb; eauto.
  Qed. 

  Lemma adr_is_ctr_false_arbitrator: 
    address_is_contract arbitrator_adr = false. 
  Proof.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    destruct Hex as (ctx & stp & st & Hst & Hini).
    simpl in Hini. 
    reduce_init_escrow.
    do 4 match goal with
        H: _ && _ = true |- _ => apply andb_prop in H; destruct H
      end.
    eapply address_not_contract_negb; eauto.
  Qed. 

  Lemma adr_neq_buyer_caddr: 
    address_neqb buyer_adr caddr = true.
  Proof.
    pose proof adr_is_ctr_false_buyer as Haicf.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    eapply contract_addr_format in Hec; eauto.
    lets H__: address_eqb_spec buyer_adr caddr.
    inverts H__.
    - subst caddr. false.
    - eapply adr_neq_reflect; eauto.
  Qed. 

  Lemma adr_neq_arb_adr_caddr: 
    address_neqb arbitrator_adr caddr = true.
  Proof.
    pose adr_is_ctr_false_arbitrator as Haiaf.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    eapply contract_addr_format in Hec; eauto.
    lets H__: address_eqb_spec arbitrator_adr caddr.
    inverts H__.
    - rewrite H0 in Haiaf. false. 
    - eapply adr_neq_reflect; eauto.
  Qed. 

  Lemma adr_neq_seller_adr_caddr: 
    address_neqb seller_adr caddr = true.
  Proof.
    pose adr_is_ctr_false_seller as Haiaf.
    unfolds in H_init.
    destruct H_init as (Hrc & Hcsq & Hec & Hex).
    eapply contract_addr_format in Hec; eauto.
    lets H__: address_eqb_spec seller_adr caddr.
    inverts H__.
    - rewrite H0 in Haiaf. false. 
    - eapply adr_neq_reflect; eauto.
  Qed. 
    
  Lemma caddr_not_mnr :
    caddr <> miner.
  Proof.
    introv Hf.
    unfolds in H_init.
    destruct H_init as (hrc & Hcsq & Hec & Hex).
    eapply contract_addr_format in Hec; eauto.
    pose proof addr_ctr_neq as HH.
    lets H_: HH Hec H_miner.
    apply H_.
    auto.
  Qed.     

  (**)
  (* satisfaction of strategy-aware liquidity under honest buyer and arbitrator *) 
  
  Definition honest_buyer_strat : (strat miner [buyer_adr; arbitrator_adr]) := 
    fun s0 (s: ChainState) tr =>
      match @contract_state _ State Hser_state s caddr with
      | Some state =>
          match state.(currentPhase) with
          | AWAITING_SHIPMENT =>
              [buyer_call_RejectItem state]
          | AWAITING_ACCEPTANCE =>
              [buyer_call_AcceptItem state; buyer_call_RejectItem state] 
          | DISPUTED =>
              [arbitrator_call_Arbitrate state true;
               arbitrator_call_Arbitrate state false]
          | _ => []
          end
      | None => []
      end.

  
  Lemma buyer_reject_item_transition_post: 
    forall (s: ChainState) cs, 
      transition_reachable miner contract caddr s0 s-> 
      contract_state s caddr = Some cs -> 
      cs.(currentPhase) = AWAITING_SHIPMENT -> 
      exists s',
        transition miner 1 s (buyer_call_RejectItem cs) = Ok s' /\
          exists cs', 
            contract_state s' caddr = Some cs' /\
              cs'.(currentPhase) = DISPUTED. 
  Proof.
    introv Htrc Hcs Hph.
    unfold transition.
    unfold queue_isb_empty.
    eapply transition_reachable_queue_is_empty in Htrc as Hqueue_s;eauto.
    rewrite Hqueue_s.
    unfold evaluate_action.
    pose proof get_valid_header_is_valid_header as Hvhd.
    unfold liqVerif in Hvhd; simpl in Hvhd.
    rewrite Hvhd; auto.
    unfold buyer_call_RejectItem.
    simpl.
    asserts_rewrite (address_neqb buyer_adr buyer_adr = false).
    { eapply address_neqb_eq; eauto. }
    rewrite adr_is_ctr_false_buyer.
    assert (Hr: reachable s).
    { eapply transition_reachable_impl_reachable in Htrc; eauto. }
    assert (Hgez: env_account_balances s buyer_adr >= 0).
    { eapply account_balance_nonnegative; eauto. }
    assert (Hec: env_contracts s caddr = Some (contract:WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htr.
      unfold liqVerif in Htr; simpl in Htr.
      eapply Htr; eauto.
    }
    unfold send_or_call.
    dc Elt tryfalse.
    dc Egt idtac.
    { simpl in Egt. destruct_address_eq; try congruence. 
      unfold miner_reward in Egt. lia. lia. }
    simpl.
    rewrite Hec; simpl.
    unfolds in Hcs; simpl in Hcs.
    destruct_head Hcs Eecs tryfalse.
    rewrite Hcs; simpl.
    rewrite deserialize_serialize.
    simpl.
    unfold receive. simpl.
    unfold require_not_self_call; simpl.
    rewrite adr_neq_buyer_caddr. simpl.
    unfold rejectItem; simpl.
    dc Erp idtac.
    2: {
      unfold require_phase in Erp. rewrite Hph in Erp.
      simpl in Erp. false.
    }
    simpl.
    eexists; splits; eauto.
    simpl. unfold set_contract_state; simpl.
    unfold transfer_balance; simpl.
    unfold add_new_block_to_env, contract_state; simpl.
    rewrite address_eq_refl.
    rewrite deserialize_serialize.
    eexists; splits; eauto.
  Qed. 

  Lemma buyer_accept_item_transition_post: 
    forall (s: ChainState) cs, 
      transition_reachable miner contract caddr s0 s-> 
      contract_state s caddr = Some cs -> 
      cs.(currentPhase) = AWAITING_ACCEPTANCE -> 
      exists s',
        transition miner 2 s (buyer_call_AcceptItem cs) = Ok s' /\ 
          exists cs', 
            contract_state s' caddr = Some cs' /\
              cs'.(currentPhase) = COMPLETED. 
  Proof.
    introv Htrc Hcs Hph.
    unfold transition.
    unfold queue_isb_empty.
    eapply transition_reachable_queue_is_empty in Htrc as Hqueue_s;eauto.
    rewrite Hqueue_s.
    unfold evaluate_action.
    pose proof get_valid_header_is_valid_header as Hvhd.
    unfold liqVerif in Hvhd; simpl in Hvhd.
    rewrite Hvhd; auto.
    unfold buyer_call_AcceptItem.
    simpl.
    assert (Hcbne: caddr <> buyer_adr).
    {
      pose proof adr_neq_buyer_caddr.
      eapply adr_neq_reflect in H; eauto.
    }
    assert (Hcmne: caddr <> miner). { apply caddr_not_mnr. }
    asserts_rewrite (address_neqb buyer_adr buyer_adr = false).
    { eapply address_neqb_eq; eauto. }
    rewrite adr_is_ctr_false_buyer.
    assert (Hr: reachable s).
    { eapply transition_reachable_impl_reachable in Htrc; eauto. }
    assert (Hgez: env_account_balances s buyer_adr >= 0).
    { eapply account_balance_nonnegative; eauto. }
    assert (Hcgez: env_account_balances s caddr >= 0).
    { eapply account_balance_nonnegative; eauto. }
    assert (Hec: env_contracts s caddr = Some (contract:WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htr.
      unfold liqVerif in Htr; simpl in Htr.
      eapply Htr; eauto.
    }
    assert (Hcs__:= Hcs).
    unfold send_or_call.
    dc Elt tryfalse.
    dc Egt idtac.
    { simpl in Egt. destruct_address_eq; try congruence. 
      unfold miner_reward in Egt. lia. lia. }
    simpl.
    rewrite Hec; simpl.
    unfolds in Hcs; simpl in Hcs.
    destruct_head Hcs Eecs tryfalse.
    rewrite Hcs; simpl.
    rewrite deserialize_serialize.
    simpl.
    unfold receive; simpl.
    unfold require_not_self_call; simpl.
    rewrite adr_neq_buyer_caddr. simpl.
    unfold acceptItem; simpl.
    dc Erp idtac.
    2: {
      unfold require_sender in Erp. simpl in Erp.
      lets H__: seller_buyer_arbitrator_addr Hr Hec.
      destruct H__ as (cs_ & Hcs_ & Hb_ & Hs_ & Ha_).
      rewrite Hcs__ in Hcs_. inverts Hcs_. rewrite Hb_ in Erp. 
      rewrite address_eq_refl in Erp.
      unfold require_phase in Erp. rewrite Hph in Erp.
      simpl in Erp. false. 
    }
    simpl.
    unfold send_or_call.
    lets H__: balance_on_chain Hr Hec.
    destruct H__ as (cs_ & Hcs_ & Heq).
    rewrite Hcs_ in Hcs__. inverts Hcs__.
    unfold outgoing_acts in Heq.
    rewrite Hqueue_s in Heq.
    simpl in Heq.
    dc Elt_ tryfalse.
    { rewrite <- Heq in Elt_. lia. } 
    dc Egt_ tryfalse.
    {
      simpl in Egt_.
      destruct_address_eq; try congruence; tryfalse. 
      false. lia.
    }
    simpl.
    assert (Hseller: seller cs = seller_adr).
    {
      lets H__: seller_buyer_arbitrator_addr Hr Hec.
      destruct H__ as (cs_ & Hcs__ & Hb_ & Hs_ & Ha_).
      rewrite Hcs_ in Hcs__. inverts Hcs__.
      tauto.
    }
    assert (Haics: address_is_contract seller_adr = false).
    { apply adr_is_ctr_false_seller. }
    assert (Hns: env_contracts s (seller cs) = None).
    {
      eapply address_not_contract_not_wc; eauto.
      congruence.
    }
    rewrite Hns.
    rewrite <- Hseller in Haics. rewrite Haics.
    simpl. 
    eexists; splits; eauto.
    simpl. unfold transfer_balance, set_contract_state, contract_state; simpl.
    rewrite address_eq_refl.
    rewrite deserialize_serialize.
    eexists; splits; eauto.
  Qed.     

  Lemma arbitrator_arbitrate_transition_post: 
    forall (s: ChainState) cs, 
      transition_reachable miner contract caddr s0 s-> 
      contract_state s caddr = Some cs -> 
      cs.(currentPhase) = DISPUTED -> 
      exists s',
        transition miner 2 s (arbitrator_call_Arbitrate cs true) = Ok s' /\ 
          exists cs', 
            contract_state s' caddr = Some cs' /\
              cs'.(currentPhase) = COMPLETED. 
  Proof.
    introv Htrc Hcs Hph.
    unfold transition.
    unfold queue_isb_empty.
    eapply transition_reachable_queue_is_empty in Htrc as Hqueue_s;eauto.
    rewrite Hqueue_s.
    unfold evaluate_action.
    pose proof get_valid_header_is_valid_header as Hvhd.
    unfold liqVerif in Hvhd; simpl in Hvhd.
    rewrite Hvhd; auto.
    unfold arbitrator_call_Arbitrate.
    simpl.
    assert (Hr: reachable s).
    { eapply transition_reachable_impl_reachable in Htrc; eauto. }
    asserts_rewrite (address_neqb arbitrator_adr arbitrator_adr = false).
    { eapply address_neqb_eq; eauto. }
    assert (Harbcf: address_is_contract arbitrator_adr = false).
    { apply adr_is_ctr_false_arbitrator. }
    assert (Hcgez: env_account_balances s arbitrator_adr >= 0).
    { eapply account_balance_nonnegative; eauto. }
    assert (Hcgec: env_account_balances s caddr >= 0).
    { eapply account_balance_nonnegative; eauto. }
    assert (Hec: env_contracts s caddr = Some (contract:WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htr.
      unfold liqVerif in Htr; simpl in Htr.
      eapply Htr; eauto.
    }
    assert (Hcs_ := Hcs).
    rewrite Harbcf.
    unfold send_or_call. simpl.
    dc Egt tryfalse.
    { destruct_address_eq; try congruence.
      unfold miner_reward in Egt. lia. lia. }
    rewrite Hec.
    unfolds in Hcs; simpl in Hcs.
    destruct_head Hcs Ee tryfalse.
    simpl. rewrite Hcs; simpl.
    rewrite deserialize_serialize.
    simpl.
    unfold receive; simpl.
    dc Econd tryfalse.
    2: { unfold require_not_self_call in Econd; simpl in Econd.
         pose proof adr_neq_arb_adr_caddr. false. }
    unfold arbitrate.
    unfold require_phase, require_sender; simpl.
    rewrite Hph; simpl.
    assert (Harb: arbitrator cs = arbitrator_adr). 
    {
      lets H__: seller_buyer_arbitrator_addr Hr Hec.
      destruct H__ as (cs_ & Hcs__ & Hb_ & Hs_ & Ha_).
      rewrite Hcs_ in Hcs__. inverts Hcs__.
      tauto.
    }
    rewrite Harb.
    rewrite address_eq_refl; simpl.
    unfold send_or_call.
    lets H__: balance_on_chain Hr Hec.
    destruct H__ as (cs_ & Hcs__ & Heq).
    rewrite Hcs__ in Hcs_. inverts Hcs_.
    unfold outgoing_acts in Heq.
    rewrite Hqueue_s in Heq.
    simpl in Heq.
    dc Elt (try lia).
    assert (Hcmne: caddr <> miner). { apply caddr_not_mnr. }
    assert (Hcane: caddr <> arbitrator_adr).
    {
      pose proof adr_neq_arb_adr_caddr. 
      eapply adr_neq_reflect in H; eauto.
    }
    dc Egg idtac.
    {
      simpl in Egg.
      destruct_address_eq; try congruence.
      lia. lia.
    }
    unfold set_contract_state; simpl.
    assert (Hbuyer: buyer cs = buyer_adr).
    {
      lets H__: seller_buyer_arbitrator_addr Hr Hec.
      destruct H__ as (cs_ & Hcs___ & Hb_ & Hs_ & Ha_).
      rewrite Hcs__ in Hcs___. inverts Hcs___.
      tauto.
    }
    assert (Haics: address_is_contract buyer_adr = false).
    { apply adr_is_ctr_false_buyer. }
    assert (Hns: env_contracts s (buyer cs) = None).
    {
      eapply address_not_contract_not_wc; eauto.
      congruence.
    }
    rewrite Hns.
    rewrite Hbuyer.
    rewrite Haics; simpl.
    eexists; splits; eauto.
    simpl. unfold transfer_balance, contract_state; simpl.
    rewrite address_eq_refl; simpl.
    rewrite deserialize_serialize.
    eexists; splits; eauto.
  Qed.     

  (* buyer and arbitrator are honest; any other account could be dishonest *) 
  Theorem escrow_sat_liq_honest_buyer: 
    forall d_addrs d_strat, 
      strat_liquidity miner
        [buyer_adr; arbitrator_adr] honest_buyer_strat d_addrs d_strat contract caddr s0.
  Proof.
    (* introv (* Hnin *) Ha Hws. *)
    intros. 
    eapply strat_liq_inst.
    lets H__: soundness; eauto.
    eapply H__; eauto; clear H__.    
    { apply VC_R_holds. }
    { apply VC_B_holds. } 
    { eapply VC_A_holds; eauto. }
    {
      unfolds.
      introv Hif Hvf Hmnin.
      unfold Var in *. unfold liqVerif in *.
      unfolds in Hif. unfolds in Hif.
      destruct Hif as (Htrc & Hex). 
      unfolds in Hvf.
      destruct_head Hvf Eccs tryfalse.
      inverts Hvf.      
      destruct s.(currentPhase) eqn: Eph.
      - lets H__: buyer_reject_item_transition_post Htrc Eccs Eph.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_buyer_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
      - lets H__: buyer_accept_item_transition_post Htrc Eccs Eph.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_buyer_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
      - false. apply Hmnin. apply minimal_completed. 
      - lets H__: arbitrator_arbitrate_transition_post Htrc Eccs Eph.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_buyer_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
    }      
  Qed.

  
  (**)
  (* satisfaction of strategy-aware liquidity under honest seller and arbitrator *) 

  Definition honest_seller_strat : (strat miner [seller_adr; arbitrator_adr]) :=
    fun s0 s tr  =>
      match @contract_state _ State Hser_state s caddr with 
      | Some state =>
          match state.(currentPhase) with
          | AWAITING_SHIPMENT =>
              [seller_call_MarkAsShipped state]
          | AWAITING_ACCEPTANCE =>
              [seller_call_RejectItem state]
          | DISPUTED =>
              [(arbitrator_call_Arbitrate state true);
               (arbitrator_call_Arbitrate state false)]
          | _ => []
          end
      | None => []
      end.

  Lemma seller_mark_shipped_transition_post: 
    forall (s: ChainState) cs, 
      transition_reachable miner contract caddr s0 s-> 
      contract_state s caddr = Some cs -> 
      cs.(currentPhase) = AWAITING_SHIPMENT -> 
      exists s',
        transition miner 1 s (seller_call_MarkAsShipped cs) = Ok s' /\
          exists cs', 
            contract_state s' caddr = Some cs' /\
              cs'.(currentPhase) = AWAITING_ACCEPTANCE. 
  Proof.
    introv Htrc Hcs Hph.
    unfold transition.
    unfold queue_isb_empty.
    eapply transition_reachable_queue_is_empty in Htrc as Hqueue_s;eauto.
    rewrite Hqueue_s.
    unfold evaluate_action.
    pose proof get_valid_header_is_valid_header as Hvhd.
    unfold liqVerif in Hvhd; simpl in Hvhd.
    rewrite Hvhd; auto.
    unfold seller_call_MarkAsShipped.
    simpl.
    asserts_rewrite (address_neqb seller_adr seller_adr = false).
    { eapply address_neqb_eq; eauto. }
    assert (Haics: address_is_contract seller_adr = false).
    { apply adr_is_ctr_false_seller. }
    assert (Hr: reachable s).
    { eapply transition_reachable_impl_reachable in Htrc; eauto. }    
    assert (Hbalsa: env_account_balances s seller_adr >= 0).
    { eapply account_balance_nonnegative; eauto. } 
    assert (Hcs_ := Hcs).
    assert (Hec: env_contracts s caddr = Some (contract:WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htr.
      unfold liqVerif in Htr; simpl in Htr.
      eapply Htr; eauto.
    }
    rewrite Haics.
    unfold send_or_call.
    dc Elt tryfalse.
    dc Egt idtac.
    {
      unfold add_new_block_to_env in Egt; simpl in Egt.
      destruct_address_eq; try congruence.
      unfold miner_reward in Egt. lia. lia.
    }
    unfold add_new_block_to_env; simpl.
    rewrite Hec.
    unfolds in Hcs; simpl in Hcs.
    destruct_head Hcs Ecs tryfalse.
    simpl. rewrite Hcs; simpl.
    rewrite deserialize_serialize; simpl.
    unfold receive; simpl.
    unfold require_not_self_call. unfold ctx_from.
    simpl. 
    rewrite adr_neq_seller_adr_caddr.
    unfold markAsShipped. simpl.
    unfold require_phase. rewrite Hph.
    unfold require_sender. simpl.
    assert (Hbuyer: seller cs = seller_adr).
    {
      lets H__: seller_buyer_arbitrator_addr Hr Hec.
      destruct H__ as (cs_ & Hcs___ & Hb_ & Hs_ & Ha_).
      rewrite Hcs_ in Hcs___. inverts Hcs___.
      tauto.
    }
    rewrite Hbuyer. rewrite address_eq_refl.
    simpl.
    eexists; splits; eauto.
    simpl. unfold set_contract_state; simpl.
    unfold transfer_balance, contract_state; simpl.
    rewrite address_eq_refl.
    rewrite deserialize_serialize. eexists; splits; eauto.
  Qed.

  Lemma seller_reject_item_transition_post: 
    forall (s: ChainState) cs, 
      transition_reachable miner contract caddr s0 s-> 
      contract_state s caddr = Some cs -> 
      cs.(currentPhase) = AWAITING_ACCEPTANCE -> 
      exists s',
        transition miner 1 s (seller_call_RejectItem cs) = Ok s' /\ 
          exists cs', 
            contract_state s' caddr = Some cs' /\
              cs'.(currentPhase) = DISPUTED. 
  Proof.
    introv Htrc Hcs Hph.
    unfold transition.
    unfold queue_isb_empty.
    eapply transition_reachable_queue_is_empty in Htrc as Hqueue_s;eauto.
    rewrite Hqueue_s.
    unfold evaluate_action.
    pose proof get_valid_header_is_valid_header as Hvhd.
    unfold liqVerif in Hvhd; simpl in Hvhd.
    rewrite Hvhd; auto.
    unfold seller_call_RejectItem.
    simpl.
    asserts_rewrite (address_neqb seller_adr seller_adr = false).
    { eapply address_neqb_eq; eauto. }
    assert (Haics: address_is_contract seller_adr = false).
    { apply adr_is_ctr_false_seller. }
    assert (Hr: reachable s).
    { eapply transition_reachable_impl_reachable in Htrc; eauto. }    
    assert (Hbalsa: env_account_balances s seller_adr >= 0).
    { eapply account_balance_nonnegative; eauto. } 
    assert (Hec: env_contracts s caddr = Some (contract:WeakContract)).
    {
      pose proof trans_rc_env_contracts as Htr.
      unfold liqVerif in Htr; simpl in Htr.
      eapply Htr; eauto.
    }
    assert (Hcs_ := Hcs).
    rewrite Haics.
    unfold send_or_call.
    dc Elt tryfalse.
    dc Egt idtac.
    {
      simpl in Egt.
      destruct_address_eq; try congruence.
      unfold miner_reward in Egt. lia. lia.
    }
    simpl.
    rewrite Hec.
    unfolds in Hcs; simpl in Hcs.
    destruct_head Hcs Ecs tryfalse.
    simpl; rewrite Hcs; simpl.
    rewrite deserialize_serialize; simpl.
    unfold receive. 
    unfold require_zero. unfold ctx_amount.
    simpl.
    unfold require_not_self_call. simpl.
    rewrite adr_neq_seller_adr_caddr; simpl.
    unfold rejectItem; simpl.
    unfold require_phase. rewrite Hph; simpl.
    eexists; splits; eauto.
    simpl.
    unfold set_contract_state; simpl.
    unfold contract_state, transfer_balance; simpl.
    rewrite address_eq_refl.
    rewrite deserialize_serialize.
    eexists; splits; eauto.
  Qed.
  
  (* seller and arbitrator are honest; any other account could be dishonest *) 
  Theorem escrow_sat_liq_honest_seller: 
    forall d_addrs d_strat, 
      strat_liquidity miner
        [seller_adr; arbitrator_adr] honest_seller_strat d_addrs d_strat contract caddr s0.
  Proof.
    intros. 
    eapply strat_liq_inst.
    lets H__: soundness; eauto.
    eapply H__; eauto; clear H__.    
    { apply VC_R_holds. }
    { apply VC_B_holds. } 
    { eapply VC_A_holds; eauto. }
    {
      unfolds.
      introv Hif Hvf Hmnin.
      unfold Var in *. unfold liqVerif in *.
      unfolds in Hif. unfolds in Hif.
      destruct Hif as (Htrc & Hex). 
      unfolds in Hvf.
      destruct_head Hvf Eccs tryfalse.
      inverts Hvf.      
      destruct s.(currentPhase) eqn: Eph.
      - lets H__: seller_mark_shipped_transition_post Htrc Eccs Eph; eauto.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_seller_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
      - lets H__: seller_reject_item_transition_post Htrc Eccs Eph; eauto.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_seller_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
      - false. apply Hmnin. apply minimal_completed. 
      - lets H__: arbitrator_arbitrate_transition_post Htrc Eccs Eph.
        destruct H__ as (s' & Htrans & H_ex).
        destruct H_ex as (cs' & Hcs' & Hcp).
        do 2 eexists. splits; eauto.
        constructors. eexists. exists Htrans.
        splits; eauto.
        unfold honest_seller_strat.
        unfold liqVerif; simpl.
        rewrite Eccs.
        rewrite Eph. simpl; auto.
        assert (Htrc': transition_reachable miner contract caddr s0 s').
        {
          eapply transition_reachable_transition_transition_reachable; eauto.
        }
        eapply transition_reachable_inv; eauto.
        unfold var_func. rewrite Hcs'.
        eexists; splits; eauto.
        rewrite Hcp. unfold Ord. constructors.
    }
    
  Qed. 
          
End Liquidity.
